import sys
import pathlib
from dataclasses import dataclass
from xml.dom import minidom
import jinja2
import os
import hashlib

CACHE_FILE_PATH: str = os.path.join(os.path.abspath(os.path.dirname(__file__)), 'cache.txt')

#region global functions

def print_usage():
    print('USAGE:')
    print('    [0] resource file absolute path')
    print('    [1] output converter absolute path')
    print('    [2] the namespace for the generated class')
    print('    [3] the full name of the autogenerated resource file class. with namespace included')

#endregion

@dataclass
class ResourceFileCtx:
    
    elements_keys: list[str]

def get_resource_file_context(abs_path: str) -> ResourceFileCtx:
    if not pathlib.PurePath(abs_path).suffix == '.resx':
        print(abs_path)
        print('ERROR: the resource file should end with .resx')
        exit(-1)

    resource_file_xml_dom_tree: minidom.Document = minidom.parse(abs_path)

    data_items = resource_file_xml_dom_tree.getElementsByTagName('data')

    keys: list[str] = []

    for item in data_items:
        name_attr = item.attributes.get('name')
        if name_attr:
            keys.append(name_attr.value)
    
    return ResourceFileCtx(keys)

def get_file_hash(file_path: str) -> str:
    if not os.path.exists(file_path):
        return ''

    with open(file_path, 'rb') as f:
        file_content: bytes = f.read()
    
    sha1_alg = hashlib.sha1()

    sha1_alg.update(file_content)

    return sha1_alg.hexdigest()

def is_output_up_to_date(output_path: str, in_file_path: str) -> bool:
    global CACHE_FILE_PATH

    if not os.path.exists(CACHE_FILE_PATH):
        return False

    with open(CACHE_FILE_PATH, 'r') as f:
        cache_content: list[str] = f.readlines()

        if not len(cache_content) == 2:
            return False
        
        input_file_hash, output_file_hash = [line.strip() for line in cache_content]

    return input_file_hash == get_file_hash(in_file_path)\
            and output_file_hash == get_file_hash(output_path)

def create_cache_file(output_path: str, in_file_path: str): 
    global CACHE_FILE_PATH
    with open(CACHE_FILE_PATH, 'w') as f:
        f.write(f'{get_file_hash(in_file_path)}\n')
        f.write(get_file_hash(output_path))

if __name__ == '__main__':
    if len(sys.argv) == 2 and sys.argv[1].lower() == 'help':
        print_usage()
        exit(0)

    if len(sys.argv) < 5:
        print('ERROR: no enough arguments passed')
        print_usage()
        exit(-1)

    resource_file_abs_path = sys.argv[1]
    output_converter_path = sys.argv[2]
    converter_namespace = sys.argv[3]
    resource_file_full_name_class = sys.argv[4]

    if is_output_up_to_date(output_converter_path, resource_file_abs_path):
        print('the converter to generate is already up to date')
        exit(0)

    resource_file_ctx = get_resource_file_context(resource_file_abs_path)

    template_loader = jinja2.FileSystemLoader(f'{os.path.dirname(__file__)}')
    template_environment = jinja2.Environment(loader=template_loader, trim_blocks= True, lstrip_blocks= True)

    template_ctx = {
        'resource_keys': resource_file_ctx.elements_keys,
        'resource_file_full_name_class': resource_file_full_name_class,
        'resource_file_namespace': '.'.join(resource_file_full_name_class.split('.')[:-1]),
        'converter_name': pathlib.PurePath(output_converter_path).stem,
        'converter_namespace': converter_namespace,
        'resource_file_class_name': resource_file_full_name_class.split('.')[-1]
    }

    resource_dynamic_converter_template = template_environment.get_template('ResourceDynamicConverterTemplate.txt')

    resource_dynamic_converter_template.stream(template_ctx).dump(output_converter_path)

    create_cache_file(output_converter_path, resource_file_abs_path)

    print('converter generated succesfully!')
